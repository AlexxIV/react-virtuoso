{"componentChunkName":"component---src-pages-virtuoso-api-reference-js","path":"/virtuoso-api-reference/","result":{"data":{"virtuosoApi":"## Properties of the `Virtuoso` Component\n\n### `totalCount: number`\n\nMandatory. Specifies the total amount of items to be displayed by the list.\n\n### `item: (index: number) => ReactElement`\n\nMandatory. Specifies how each item gets rendered. The callback receives the zero-based index of the item.\n\n### `style?: CSSProperties`\n\nOptional; most often, you will need to tweak the size of the component by setting `width` and `height`.\nThe style is passed to the outermost `div` element of the component.\n\n### `className?: string`\n\nOptional; sets the CSS class of the outermost element of the component.\n\n### `footer?: () => ReactElement`\n\nOptional. Defines content to be rendered at the bottom of the list.\n\n### `overscan?: number`\n\nOptional. Causes the component to render extra content in addition to the necessary one to fill in the visible viewport.\n\n### `initialItemCount?: number`\n\nOptional, use if you are using server-side rendering (SSR) and would like to have some amount of items initially rendered regardless of the item/container size.\n\n### `initialTopMostItemIndex?: number`\n\nSetting this property causes the component to \"start\" the list from the specified index when mounted.\nUse this only to specify the initial state on mount. Use the `scrollToIndex` method if the component is already mounted.\n\n### `itemHeight?: number`\n\nCan be used to improve performance if the rendered items are of known size. Setting it causes the component to skip item measurements. See the Tweaking Performance section for more details.\n\n### `defaultItemHeight?: number`\n\nBy default, the component assumes the default item height from the first rendered item (rendering it as a \"probe\").\nIf the first item turns out to be an outlier (very short or tall), the rest of the rendering will be slower, as multiple passes of rendering should happen for the list to fill the viewport.\nSetting this property causes the component to skip the \"probe\" rendering and use the property value instead.\n\n### `ScrollContainer: React.FC`\n\nOptional. Can be used to replace and extend the scrollable element of the component.\nCheck the [custom scroll container](/custom-scroll-container) for sample usage.\n\n### `computeItemKey?: (index: number) => number`\n\nOptional - if specified, the component will use the provided function to generate the `key={}` property for each list item.\n\n### `maxRangeSize?: number`\n\nOptional - use **only** if you have very large lists with uneven item sizes and you observe performance issues with rendering. Controls the maximum size of the size caching data structure.  \nOnce the cache size is exceeded, the structure is \"reset\" to the default size, discarding the sizes of the items outside of the viewport. \nA recommended size would be somewhere in the low thousands. \n\n### `followOutput?: boolean`\n\nIf set to `true`, the list will automatically scroll to bottom if the total count is changed. See the [Stick to Bottom](/stick-to-bottom) scenario for a working example.\n\n### `scrollSeek?: ScrollSeekConfiguration`\n\nThe `scrollSeek` property can be used to display placeholders if the user scrolls fast through the list. The type looks like this:\n\n```ts\ninterface ScrollSeekConfiguration {\n  // Controls when the component enters scroll seeking state. \n  // Moderately fast scrolling generates velocity around 100.\n enter: (velocity: number, index: number) => boolean\n  // Controls when the component exits scroll seeking state\n exit: (velocity: number, index: number) => boolean \n // Use to update an indicator of the list location during scroll seek\n change: (velocity: number, index: number) => void\n // Configures the seek placeholder\n placeholder: React.ComponentType<{height: number, index: number}\n}\n```\n\n## Callback Properties\n\n### `scrollingStateChange?: (isScrolling: boolean) => void`\n\nGets called when the user starts / stops scrolling. Can be used to hide complex item contents during scrolling.\n\n### `endReached?: (index: number) => void`\n\nGets called when the user scrolls to the end of the list.\nReceives the last item index as an argument. Can be used to implement [endless scrolling](/endless-scrolling).\n\n### `totalListHeightChanged?: (height: number) => void`\n\nOptional. Gets called each time the total height of the list gets re-computed. Notice that the value is just an estimate based on what's rendered so far.\n\n### `itemsRendered?: (items: Array<{ transposedIndex: number }>) => void`\n\nOptional. The callback is called with the new set of items each time the list items are rendered due to scrolling.\n\n### `rangeChanged?: (range: { startIndex: number, endIndex: number }) => void`\n\nOptional. Gets called with the top / bottom index of the currently rendered list range.\n\n### `atBottomStateChange?: (atBottom: boolean) => void`\n\nOptional. Gets called with `true` / `false` when the list has reached the bottom / gets scrolled up.  See the [Stick to Bottom](/stick-to-bottom) scenario for a possible application.\n\n## Methods\n\n### `scrollToIndex(location: number | { index: number, align: 'start'|'center'|'end' }): void`\n\nScrolls the specified item into view. Passing the longer form allows the item to be aligned to the top, center or end of the list.\n\n### `adjustForPrependedItems(count: number): void`\n\nCall when you are increasing the `totalCount` with the intend to prepend items to the top of the list. \nCheck the [Prepend Items Scenario](/prepend-items) for a working example.\n\nScrolls the specified item into view. Passing the longer form allows the item to be aligned to the top, center or end of the list.\n"},"pageContext":{"isCreatedByStatefulCreatePages":true}}}